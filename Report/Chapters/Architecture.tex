\chapter{Architecture}
\label{cha:architecture}

\todo{Blegh!...}This chapter introduces the architecture of the new tile that has been developed. 

\section{Hashing tile with DMA module}

In order to test the effects of accelerating SHA256 hashing, a new tile has been developed for
SHMAC, which can be seen in figure \ref{fig:SHA-Tile}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/Tile/HashingTile}
    \caption{SHMAC tile with SHA256 accelerator and DMA, with a wishbone arbiter added to arbitrate between the two wishbone masters}
    \label{fig:SHA-Tile}
\end{figure}

The new tile is derived from the existing CPU tile for SHMAC, the Turbo Amber tile, which contains
a ``Turbo Amber'' CPU, which is an improved version of the open-source Amber CPU, providing various
performance optimizations over the original Amber and supporting the ARMv4t instruction set \cite{turboamber}.

In addition, the tile provides two timer modules and an interrupt controller, in addition to required
tile interfaces and a router module.\todo{Consider adding this to figure?}

\subsection{SHA-256 Hashing Module}

The hashing module made for this project is a simple implementation of the algorithm described in
appendix \ref{app:hashing-algo}. It uses 65 cycles to compute the hash of its input data, running
one iteration of the SHA256 compression function every cycle except cycle 65, which is used to
form new intermediate hash values from the results of the compression function.

The module is controlled by the processor using a memory-mapped interface. This allows the use
of a DMA to offload data transfer between memory and the hashing module. The memory-mapped interface
provides registers for 512 bits of input and 256 bits of output data, in addition to control and
status registers. This interface can also be used for accelerators of other cryptographic hash
functions which processes input data of the same length and returns a hash of 256 bits or less,
such as RIPEMD-160 or RIPEMD-256 \cite{ripemd} or the still popular MD5 algorithm \cite{md5}.

With some work, the interface could be made even more generic in order to support algorithms
with other input and output sizes; a possibility would be to eliminate the input and output
registers completely in favour of using a DMA built into the module to move data of arbitrary
sizes into and out of the module.

Another, alternative interface to the module that was considered was using the co-processor interface
of the CPU to communicate with the module. The ARM instruction set supports up to 16 coprocessors,
which can be communicated with using the \texttt{mrc} and \texttt{mcr} instructions. Using this
interface for the hashing module would, however, have made it impossible to use a DMA to transfer
data to and from the module, making the hashing process much more dependent on the CPU, limiting
its benefits as an accelerator for offloading work from the processor.

\subsection{DMA Module}
Originally made for the \todo{would need a reference} project during the Autumn 2014 at NTNU, the DMA Module has been modified further for use in this project.
It can be seen in figure \ref{fig:DMATop}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/DMA/DMATopview}
    \caption{DMA Topview, including Wishbone interface.}
    \label{fig:DMATop}
\end{figure}

The DMA module was made as part of the project to test if separate data transfers with a DMA module could improve performance and energy efficiency in the Hashing process, leveraging the tile CPU for other work and specializing this module more efficiently for data transfer.

The DMA consists of three submodules: Wishbone Slave for receiving transfer requests, Wishbone Master for interfacing data transfer with the Wishbone bus system, and the DMA module itself, which generates the individual transfer commands.

\todo{The 14th commandment: Thou shall satisfy Kristian. The 13th commandment: Thou shall satisfy ME!!!}The Wishbone Slave consists of three registers for each DMA Channel, making it six in total.
The registers are used for base source, base destination and detailing the transfer request.
When request is activated, the selected channel receives data from the slave, and executes the transfer.
An arbiter selects commands from the channels if both are active.
Every single command from the channels are passed on to the Wishbone master, which executes the command.
The command is either a load or a store command.
Any received data from a load command is passed on to the correct channel, and when a channel if finished, the imformation is passed from the Wishbone Master to the Wishbone Slave, so it can modify its registers and interrupt the CPU. 

\todo{Denne SKA med}In addition for this project, the DMA Module also has submodule for endian byte switching, since the results from the SHA-256 hashing process is stored with lowest endian byte first.
Switching the bytes instantly as they pass through the submodule should be more efficient than in software, since the software solution would require to \todo{Either put in example, or set in reference to software solution that does not use DMA, when it is added to the report.}load the data and shift the bytes for each existing byte.

\subsection{Wishbone Arbiter}
With the presence of a Wishbone Master in the DMA Module, the tile has now two masters that will demand access to the shared Wishbone bus network. 
Arbritation is therefore required.

For this project, the ARB0001a: 4 Level, Round-robin Arbiter from WISHBONE Public Domain Library for VHDL has been taken in use.
Figure \cite{fig:WBArbiter} shows how the arbitration works, with Round-robin.
The arbiter will in turn check each input master for bus requests, and grants access thereby.
If a master has no request, the arbiter will continue to the next.
For this project, only two masters are present.
Arbitration normally take a full clock cycle.
See \cite{WBLibrary} for detailed implementation.

\begin{figure}[htb]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/Tile/WBArbiter}
    \caption{Wishbone Round-robin Arbiter, as seen in \cite{WBLibrary}.}
    \label{fig:WBArbiter}
\end{figure}

\todo{Discussion of alternatives. The following may be moved to future work.}Round-robin arbiters work well in data acquisition systems where data is collected and placed into shared memory, since peripherals must often off-load data to memory on an equal basis.
The choice of this arbiter is due to using an already established Wishbone arbiter cuts away time from designing a new one, \todo{Hmm.... Sounds uncalled for}which may even end up less efficient in worse case.
An alternative to round-robin arbiters is priority arbiters.
They are usually disadvantagous in said systems, but does not have the arbitration overhead \cite{WBLibrary}.

In the case of arbitration between a CPU and a DMA Module, a priority arbiter may be used to achieve either burst mode, where DMA gets the full right on the bus until the transfer is finished, or transparent mode, where the CPU always has first right.
The latter mode gives the slowest DMA transfer, but has shown to give best overall system performance. \todo{Find those book sources again, if time. Current source does not validate claim of overall performance} \cite{DMA-lecture}.

